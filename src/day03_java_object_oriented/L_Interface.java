package day03_java_object_oriented;

import java_bean.day03.*;

/**
 * Interface关键字：
 *  概述：
 *      接口就是规范，定义的是一组规则，体现了现实世界中“如果你要...则必须...”的思想。
 *      继承是一个“是不是”的is-a的关系，而接口则是“有没有”的has-a关系。
 *
 *  格式：
 *      [修饰符] interface 接口名{
 *          接口的成员列表：
 *              公共的静态常量（JDK1.8之前，其中public static final修饰符可以省略）
 *              公共的抽象方法（JDK1.8之前，其中public abstract修饰符可以省略，接口是从多个相似类中抽象出来的规范，不需要具体实现）
 *              公共的默认方法（JDK1.8以上，其中public可以省略，但建议保留，且default不能省略）
 *              公共的静态方法（JDK1.8 以上，其中public可以省略，但建议保留，且static不能省略）
 *              私有方法（JDK1.9以上）
 *           除此之外，接口没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化（静态常量不是变量！）。
 *       }
 *       接口的定义与类的定义方式相似，但是使用interface关键字。它也会被编译成.class 文件，但一定要明确它并不是类，而是另外一种引用数据类型。
 *          引用数据类型：数组、类、接口、枚举、注解、字符串等。
 *
 * 原则：
 *     * 接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。通过接口类型的变量调用方法，最终执行的是
 *          new出来的实现类对象实现的方法体。
 *
 *     * 声明接口用interface，接口的成员声明有限制--上述格式中的接口成员列表。
 *
 *     * 类实现接口的关键字是implements，而且支持多实现。如果实现类不是抽象类，就必须实现(即重写)接口中所有的抽象方法。如果实现类既要继承父类
 *          又要实现父接口，那么继承(extends)在前，实现(implements)在后。所有父接口的抽象方法都要实现，如果抽象方法有重名的，只需要重写一次。
 *
 *     * 接口可以继承接口，关键字是extends，而且支持多继承。
 *
 *     * 接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过“接口名.静态方法名”进行调用。不能通过实现类对象或子接口调用，因为不能继承嘛。
 *          但静态常量可以被继承，因此子接口和实现类对象中都有静态常量
 *
 *     * 接口的默认方法可以选择重写或不重写。如果有冲突问题，另行处理。子类重写父接口的默认方法，要去掉default，子接口重写父接口的默认方法，
 *          不能去掉default。因为default默认方法是对接口而言的，类中没有默认方法这一概念。
 *
 * JDK1.8中的冲突问题
 *      方法冲突：一个类既继承父类，又实现接口
 *          抽象方法冲突：当父类中的成员方法与接口中的抽象方法重名时，子类可以不用再实现接口中的同名抽象方法了，因为继承于父类的同名方法
 *                      可以看作对接口中抽象方法的实现。
 *          默认方法冲突：当父类中的成员方法与父接口中的默认方法重名，且子类不重写同名的父类成员方法和父接口的默认方法时，
 *                      子类就近选择执行父类的成员方法。若子类重写，则就执行子类重写的同名方法啦。
 *
 *      接口冲突：子类实现的多个父接口，或子接口继承的多个父接口中包含方法签名相同的默认方法时，子类或子接口必须重写重名的默认方法。
 *              * 子类重写默认方法时，default关键字不可以保留，因为类中没有默认方法这一概念。
 *              * 子接口重写默认方法时，default关键字必须保留。
 *
 *      常量冲突：
 *              * 当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员属性(包含常量和变量)，并且该成员属性在子类中仍然可见时。
 *              * 当子类同时实现多个父接口，而多个父接口存在同名常量时
 *              此时在子类中想要引用父类或父接口中的常量或成员属性(包含常量和变量)时,就会有命名冲突问题。
 *
 * 面试题：
 *      1、为什么接口中只能声明公共的静态常量？
 *          答：因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则会破坏规范。
 *
 *      2、为什么JDK1.8之后允许接口定义静态方法和默认方法呢？
 *          答：如果接口没有静态方法和默认方法，则违反了一个抽象标准定义的概念。
 *          静态方法：因为之前的标准类库设计中有很多，如Collection/Collections或者Path/Paths这样成对的接口和类，后面的类中都是静态方法，
 *                  而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。
 *          默认方法：1)我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类，必须来实现这个新的抽象方法，
 *                      那么为了保持与旧版本代码的兼容性，只能允许在接口中定义新的默认方法，来增加接口的功能。
 *                   2)当接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，
 *                      那么实现类就可以选择重写，也可以选择不重写。
 *
 *       3、为什么JDK1.9要允许接口定义私有方法呢？
 *          答：因为接口是规范，规范是需要公开让大家遵守的。有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法有共同的代码
 *              可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。
 *
 * 接口VS抽象类
 *  区别               抽象类                                接口
 *  定义          可以包含抽象方法的类                  主要是抽象方法和全局静态常量的集合
 *  组成          构造、抽象、普通方法；常、变量         常量、抽象方法、(jdk1.8静态方法、默认方法)(jdk1.9私有方法)
 *  使用          子类继承(extends)抽象类              子类实现(implements)接口
 *  关系          抽象类可以实现多个接口                 接口不能继承抽象类、但允许继承多个接口
 *  设计模式       模板方法                             简单工厂、工厂方法、代理模式
 *  对象                     都通过对象的多态性产生实例对象
 *  局限          抽象类有单继承的局限                  接口没有此局限，可以多继承
 *  实际          作为一个模板                          是作为一个标准或表示一种能力
 *  选择                     如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限。
 *
 * @ClassName: L_Interface.java
 * @Author: anpeng
 * @Date: 2023/11/1 17:25
 */
public class L_Interface {
    public static void main(String[] args) {
        //测试接口引用变量与实现类对象构成多态
        Computer.show(new Flash());//show(USB usb);Flash类和Print类都实现了USB接口，USB类型引用指向不同实现类对象时，执行不同方法。
        Computer.show(new Print());

        //测试类的多实现接口
        C c = new C();//类C实现了两个接口A和B，类C不是抽象类，必须实现所有接口的抽象方法。
        c.showA();
        c.showB();

        //测试接口的多继承
        //TypeCConverter实现接口UsbC，该接口继承了多个父接口，它的实现类需要重写所有抽象方法
        TypeCConverter typeCConverter = new TypeCConverter();
        typeCConverter.in();//USB3和Chargeable接口中的方法签名相同的抽象方法只需要实现一次
        typeCConverter.out();
        typeCConverter.reverse();
        typeCConverter.charge();

        //测试接口的默认方法--可重写，也可不重写
        typeCConverter.start();//子类重写父接口的默认方法，要去掉default。因为default默认方法是对接口而言的，类中没有默认方法这一概念。
        typeCConverter.stop();

        //测试使用接口中的静态成员--UsbC接口继承了USB3接口和Chargeable接口
        USB3.show();//只能通过“接口名."直接调用该接口的静态方法
        //UsbC.show();编译不通过，子接口不能继承父接口的静态方法。
        //c.staticMethod();编译不通过，接口的静态方法不能被继承，故接口实现类中也只有接口的抽象方法和默认方法，没有静态方法。
        A.staticMethod();
        System.out.println(USB3.MAX_SPEED);//通过“接口名.”直接使用接口的静态常量，静态常量可以被继承
        System.out.println(typeCConverter.MAX_SPEED);//实现类对象中具有父接口的静态常量
        System.out.println(UsbC.MAX_SPEED);//子接口中具有父接口的静态常量。

        //测试方法冲突问题
        Son son = new Son();
        //当父类的成员方法与父接口的抽象方法重名时
        son.date();//子类可不用实现接口中的抽象方法，因为继承于父类的同名抽象方法可以看作对接口抽象方法的实现。
        //当父类的成员方法与父接口的默认方法重名时
        son.greeting();//类优先原则，即子类不重写时同名的父类成员方法和父接口的默认方法时，子类就近选择执行父类的成员方法。

        //测试接口冲突
        c.defaultMethod();//子类实现的多个父接口中有多个同名的默认方法时，实现类必须重写该同名的默认方法。
        typeCConverter.defaultMethod();//子接口UsbC实现的多个父接口中有多个同名的默认方法时，子接口必须重写该同名的默认方法。

        //测试常量冲突
        //son.CONSTANT;编译不通过，父类和父接口中都用该同名常量。
    }
}
